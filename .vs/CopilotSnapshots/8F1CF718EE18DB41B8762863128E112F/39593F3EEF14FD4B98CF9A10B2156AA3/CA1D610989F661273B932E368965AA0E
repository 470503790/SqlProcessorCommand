# SqlProcessorCommand

> 将原始 SQL Server 脚本转换为“幂等”脚本：可多次重复执行而不会因为对象已存在/不存在等原因失败，降低发布脚本的风险。

## 背景
常规升级脚本里包含 `CREATE TABLE / CREATE PROC / DROP COLUMN / DROP TABLE / ALTER COLUMN` 等语句，若直接重复执行容易报错或造成危险行为。本工具按 `GO` 分批读取输入脚本，针对每一批尝试匹配一条规则（Transform），将其改写为“存在才创建/删除”或“条件包装”，或直接丢弃高风险语句，使整体脚本具备幂等能力。

## 命令行使用
```
SqlProcessorCommand --input <input.sql> [--output <out.sql>] [--name <tag>] [--encoding <enc>]
                    [--discard-drop-table | --keep-drop-table]
                    [--discard-drop-column | --keep-drop-column]
```

### 参数说明
| 选项 | 说明 | 默认 |
|------|------|------|
| `-i, --input` | 输入 SQL 文件（必填） | - |
| `-o, --output` | 输出文件路径；若省略：`<输入名>.<tag|idempotent>.sql` | 自动生成 |
| `-n, --name` | 输出文件名中使用的自定义后缀（如 `upgrade`） | `idempotent` |
| `--encoding` | 文件编码（读写一致），示例：`utf-8`, `gbk`, `utf-16` | `utf-8` |
| `--discard-drop-table` | 丢弃所有 `DROP TABLE` 语句 | 开启 |
| `--keep-drop-table` | 保留 `DROP TABLE`，但会包装成“存在才删” | - |
| `--discard-drop-column` | 丢弃所有 `ALTER TABLE ... DROP COLUMN` | 开启 |
| `--keep-drop-column` | 保留列删除，包装成“存在才删” | - |
| `-h, --help` | 显示帮助 | - |

> `--discard-*` 与 `--keep-*` 二选一；若都不写，默认“丢弃”。

### 最简单示例
```
SqlProcessorCommand -i upgrade.sql
```
输出：`upgrade.idempotent.sql`

### 自定义后缀与保留 DROP
```
SqlProcessorCommand -i upgrade.sql -n safe --keep-drop-table --keep-drop-column
```
输出：`upgrade.safe.sql`

## 转换示例
### 1. CREATE PROCEDURE / VIEW / FUNCTION / TRIGGER
输入：
```sql
CREATE PROCEDURE dbo.p_demo AS SELECT 1;
GO
```
输出（根据版本包装为 CREATE OR ALTER，如目标 2014 采用兼容包裹）：
```sql
IF OBJECT_ID(N'dbo.p_demo', N'P') IS NULL
    EXEC('CREATE PROCEDURE dbo.p_demo AS SELECT 1;');
GO
ALTER PROCEDURE dbo.p_demo AS SELECT 1;
GO
```

### 2. DROP TABLE（默认丢弃）
输入：
```sql
DROP TABLE [dbo].[T_A];
```
默认输出：空（语句被移除）。

若使用 `--keep-drop-table`：
```sql
IF OBJECT_ID(N'[dbo].[T_A]', N'U') IS NOT NULL
    DROP TABLE [dbo].[T_A];
```

### 3. ALTER TABLE ... DROP COLUMN（默认丢弃）
输入：
```sql
ALTER TABLE dbo.T_A DROP COLUMN ObsoleteFlag;
```
默认输出：空。

使用 `--keep-drop-column` 输出：
```sql
IF COL_LENGTH(N'[dbo].[T_A]', N'ObsoleteFlag') IS NOT NULL
BEGIN
    ALTER TABLE dbo.T_A DROP COLUMN ObsoleteFlag;
END
```

### 4. ALTER COLUMN
输入：
```sql
ALTER TABLE dbo.T_A ALTER COLUMN Name NVARCHAR(100) NULL;
```
输出：
```sql
IF COL_LENGTH(N'[dbo].[T_A]', N'Name') IS NOT NULL
BEGIN
    ALTER TABLE dbo.T_A ALTER COLUMN Name NVARCHAR(100) NULL;
END
```

### 5. ADD COLUMN / ADD CONSTRAINT / 默认约束
类似地被改写为“列/约束不存在时才添加”。

## 已内置的 Transform 规则
按执行顺序（概念分组）：
- 危险删除类（可丢弃或条件包装）
  - `DropTableToEmptyTransform` / `DropTableTransform`
  - `DropColumnToEmptyTransform` / `DropColumnTransform`
- 结构与列变更
  - `AddDefaultConstraintTransform`
  - `AddConstraintTransform`
  - `AddColumnTransform`
  - `CreateTableTransform`
  - `AlterColumnTransform`
- 扩展属性
  - `ExtendedPropertyAddOrUpdateTablePositionalTransform`
  - `ExtendedPropertyAddOrUpdatePositionalTransform`
- 对象创建包装（跨版本兼容）
  - `CreateOrAlterProcedureTransform`
  - `CreateOrAlterViewTransform`
  - `CreateOrAlterTriggerTransform`
  - `ProcCreateAlterWrapper2014`
  - `ViewCreateAlterWrapper2014`
  - `TriggerCreateAlterWrapper2014`
  - `FunctionCreateAlterWrapper2014`
- 索引 / 约束 / 其他
  - `CreateIndexTransform`
  - `DropConstraintTransform`
  - `DropDefaultConstraintSmartTransform`
  - `DropIndexTransform`
- 清理
  - `ColumnPrefixDiscardTransform`
  - （以及可扩展的 `GenericRegexWrapTransform` 等自定义包装）

每个规则实现接口：
```
public interface ISqlBlockTransform {
    bool CanHandle(string block);
    string Transform(string block);
}
```
命中后即停止对该批次继续匹配（单条批次只应用一个 Transform）。

## 作为库调用
```csharp
using SqlProcessorCommand;

var options = new SqlIdempotentProcessor.Options {
    DiscardDropTable = true,      // 或 false
    DiscardDropColumn = true      // 或 false
};
var proc = new SqlIdempotentProcessor(options);
string outputSql = proc.Transform(File.ReadAllText("upgrade.sql"));
File.WriteAllText("upgrade.idempotent.sql", outputSql);
```

## 自定义管道
可参考 `SqlIdempotentProcessor.BuildDefaultPipeline` 了解顺序和策略：
1. Fork 项目后新增自定义 `ISqlBlockTransform` 实现。
2. 在构建管道处插入 `p.Add(new YourTransform());`。
3. 重新编译使用。

若需更精细的多规则匹配，可修改遍历逻辑（默认命中即停止）。

## GO 分批逻辑
- 仅识别“独立行的 GO”（大小写不敏感），允许后缀 `-- 注释`。
- 行尾与下一批之间重新插入 `GO` 分隔，保证输出脚本结构清晰。

## 编译
- 目标框架：.NET Framework 4.8
- 直接用 Visual Studio 或 `msbuild` / `dotnet build` (需安装 net48 targeting pack) 编译。

## 注意事项 / 限制
- 当前未深度解析列类型变更，只在列存在时执行 `ALTER COLUMN`。
- 不处理跨批次依赖的重排（假设原始顺序正确）。
- 只处理常见语法形态；非常规写法可能不会命中规则。
- 请在生产前审阅生成的幂等脚本，确保符合业务预期。

## License
尚未声明。如需开源分发，请补充 LICENSE 文件并在此处更新说明。

---
欢迎提交 Issue / PR 以补充更多幂等规则或改进正则匹配。
